# 백준 / DP / 1535 안녕
https://www.acmicpc.net/problem/1535   

### 문제 설명
N 명의 사람들에게 최대 한 번씩만 인사를 하려고 한다. (20 이하)  
i번째 사람에게 인사하면,  
- L[i]의 체력을 잃는다. (0 이상 100 미만)  
- J[i]의 행복을 얻는다. (0 이상 100 미만)  
체력은 100부터 시작하며, 0 보다 커야한다.  
행복은 0부터 시작하며, 행복의 최댓값을 찾으려고 한다.  

### 풀이 설명
#### 완전 탐색
모든 경우를 따져보지 않으면 최적해를 보장할 수 없다.  
각 사람에게 인사를 하거나 하지 않는 경우가 있으므로, 최대 2<sup>20</sup>번의 연산을 한다.  
약 백만 번의 연산이므로, 10 ~ 100 ms의 시간이 걸릴 것이라고 예상할 수 있다.  
#### DP
완전 탐색의 방법으로 DP를 사용하는 것이 좋아보인다.  
- 2차원 DP를 이용한다.  
  행마다 새로운 사람이 추가된다고 본다.  
  열은 현재 가지고 있는 체력을 나타낸다.  
- DP 값은 현재까지의 총 행복의 최댓값이다.  

#### DFS, 백트래킹

### 코드
#### DP 이용
```{.python}
import sys
input = sys.stdin.readline

def main():
    # 입력
    N = int(input())
    L = list(map(int, input().split()))
    J = list(map(int, input().split()))
    
    # dp
    dp = [[0] * 101 for _ in range(N+1)] # 행 및 열의 인덱스가 0일 때를 zero패딩으로 놓는다.
    for i in range(1, N+1):
        l, j = L[i-1], J[i-1]
        
        # 남은 체력(hp)이 이번에 잃을 체력(l)보다 작으면 인사할 수 없다.
        # 따라서 총 행복의 최댓값(dp)은 변화없이 이전 단계에서의 최댓값이다.
        for hp in range(1, l+1):
            dp[i][hp] = dp[i-1][hp]
        # 남은 체력(hp)이 이번에 잃을 체력(l)보다 크면 인사할 수 있다.
        # 이전 단계의 dp와 현재 인사할 경우의 dp를 비교하여 큰 값이 최댓값이다.
        for hp in range(l+1, 101):
            dp[i][hp] = max(dp[i-1][hp], dp[i-1][hp-l] + j)
    print(dp[-1][-1])
    
main()
```
