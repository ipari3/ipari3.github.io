---
category: algorithm
---

# 백준 / DP / 1535 안녕
[https://www.acmicpc.net/problem/1535](https://www.acmicpc.net/problem/1535)   

### 문제 설명
N 명의 사람들에게 최대 한 번씩만 인사를 하려고 한다. (20 이하)  
i번째 사람에게 인사하면,
- L[i]의 체력을 잃는다. (0 이상 100 미만)  
- J[i]의 행복을 얻는다. (0 이상 100 미만)  
체력은 100부터 시작하며, 0 보다 커야한다.  
행복은 0부터 시작하며, 행복의 최댓값을 찾으려고 한다.  

### 알고리즘 선택
#### 완전 탐색
모든 경우를 따져보지 않으면 최적해를 보장할 수 없다.  
각 사람에게 인사를 하거나 하지 않는 경우가 있으므로, 최대 2<sup>20</sup>번의 연산을 한다.  
약 백만 번의 연산이므로, 10 ~ 100 ms의 시간이 걸릴 것이라고 예상할 수 있다.  

##### DFS
백트래킹을 고려하지 않을 경우, O(2<sup>N</sup>)의 시간복잡도를 갖는다.

##### DP
2차원 행렬에 대해 계산하므로, O(N<sup>2</sup>)의 시간복잡도를 갖는다.  
N이 4보다 크면 DFS보다 효율이 좋아지므로, DP를 사용하는 것이 좋아보인다.  

### 알고리즘 설명
N x N 크기의 2차원 DP 행렬을 계산한다.
- DP 값은 현재까지의 총 행복의 최댓값이다.  
- 행마다 새로운 사람이 추가된다고 생각한다.  
  i행에서는 i번째 사람까지만 있다고 보고 DP를 계산한다.
  (보통 사람의 인덱스가 0부터 시작하지만,
  패딩 P=1이 있으므로, 인덱스가 1부터 시작한다고 보면 된다.)
- 열은 현재 체력을 나타낸다.  
  (현재 체력은 0보다 커야하므로 현재 체력은 j+1이어야 하지만,
  패딩 P=1이 있으므로 저절로 1부터 시작하므로 그냥 j로 놓으면 된다.)

### 코드
#### DP 이용
```{.python}
import sys
input = sys.stdin.readline

def main():
    # 입력
    N = int(input())
    L = list(map(int, input().split()))
    J = list(map(int, input().split()))
    
    # dp는 현재까지의 총 행복 최댓값이다.
    # 행 및 열의 인덱스가 0일 때를 zero패딩으로 놓는다.
    dp = [[0] * 101 for _ in range(N+1)]
    for i in range(1, N+1):
        l, j = L[i-1], J[i-1]
        
        # 현재 체력(hp)이 이번에 잃을 체력(l) 이하면 인사할 수 없다.
        # (hp=l일 때 hp-l=0이 되는데, hp>0이어야 한다.)
        # 따라서 총 행복의 최댓값(dp)은 변화없이 이전 단계에서의 최댓값이다.
        for hp in range(1, l+1):
            dp[i][hp] = dp[i-1][hp]
        # 남은 체력(hp)이 이번에 잃을 체력(l)보다 크면 인사할 수 있다.
        # 이전 단계의 dp와 현재 인사할 경우의 dp를 비교하여 큰 값이 최댓값이다.
        # 현재 인사할 경우의 값은 이전 값 dp[i-1][hp-l]과 추가될 행복 j의 합이다.
        # (hp-l인 이유는, 이전 단계(행)의 모든 열에서 체력 손실이 hp보다 작음을 보장하므로,
        # hp-l은 체력 손실이 hp-l보다 작음을 보장한다. 따라서 l만큼 더 빼도 됨이 보장되며,
        # 그 때가 이전 단계의 hp 열에 대응한다.)
        for hp in range(l+1, 101):
            dp[i][hp] = max(dp[i-1][hp], dp[i-1][hp-l] + j)
    print(dp[-1][-1])
    
main()
```
